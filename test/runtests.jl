

module IntTest
	using HW_int
	using FactCheck


	# Possible tests:
	# Are results what we expected?
	# Are weights positive, less than one, more than 0?
	# Nodes: gauss-legendre: are they in (-1,1) interval?
	# 			monte carlo: are they between 1 and 4? Avg = 2.5? Because randomly drawn..
	# Question 2: Is the price function correctly defined?
	# Note: for all tests of question 2, I impose n = 10 because the question
	#       asked only for n = 10 (and tests for question 2 are already
	 				# TIME-CONSUMING)
	# question 1 can be tested for different n's

	# Change n here
	n = 10
	facts("Tests on results") do

		@fact HW_int.question_1b(n)[1] --> roughly(4; atol=1.0) # FAIL!! Gauss-Legendre didn't produce a close estimation of the integral, so this test will fail
		@fact HW_int.question_1c(n)[1] --> roughly(4; atol=1.0)
		@fact HW_int.question_1d(n)[1] --> roughly(4; atol=1.0)

		# looking at the eqm condition, when thetas are 1 (their expected value), expected price should also be around 1
		@fact HW_int.question_2a(10)[1] --> roughly(1;atol=.05)
		# thetas have variance of 0.01 and 0.02 so the variance of price should in similar order of magnitude
		@fact HW_int.question_2a(10)[2] --> roughly(0.015;atol=.01)
		@fact HW_int.question_2a(10)[2] --> greater_than(0)

		@fact HW_int.question_2b(10)[1] --> roughly(1;atol=.05)
		@fact HW_int.question_2b(10)[2] --> roughly(0.015;atol=.01)
		@fact HW_int.question_2b(10)[2] --> greater_than(0)

	end

	facts("Tests on weights") do

			# Testing number of weights and whether each weight is in interval (0,1)
			# For the case where weights are generated by a function
		facts("Question 1b") do
			@fact length(HW_int.question_1b(n)[3]) --> n
			@fact typeof(HW_int.question_1b(n)[3]) --> Array{Float64,1}
			for i in 1:n
				@fact HW_int.question_1b(n)[3][i] --> greater_than(0)
				@fact HW_int.question_1b(n)[3][i] --> less_than(1)
			end
		end

			# For questions 1c and 1d I included weights 1/n directly in the formula

		facts("Question 2a") do
			@fact length(HW_int.question_2a(10)[3]) --> 100 # because we have 2 dims
			@fact typeof(HW_int.question_2a(10)[3]) --> Array{Float64,1}
			for i in 1:100
				@fact HW_int.question_2a(10)[3][i] --> greater_than(0)
				@fact HW_int.question_2a(10)[3][i] --> less_than(1)
			end
		end

		facts("Question 2b") do
			@fact length(HW_int.question_2b(10)[3]) --> 100 # because we have 2 dims
			@fact typeof(HW_int.question_2b(10)[3]) --> Array{Float64,1}
			for i in 1:100
				@fact HW_int.question_2b(10)[3][i] --> 1/100 # In Monte Carlo, weights should be identical
			end
		end
	end

	facts("Tests on nodes") do

		facts("Question 1b") do
			@fact length(HW_int.question_1b(n)[4]) --> n
			@fact typeof(HW_int.question_1b(n)[4]) --> Array{Float64,1}
			sum = 0
			for i in 1:n
				@fact HW_int.question_1b(n)[4][i] --> greater_than(-1)
				@fact HW_int.question_1b(n)[4][i] --> less_than(1)
				# Calculate the mean of nodes, should be around 0 since nodes are normally dist. between -1 and 1
				sum = sum + HW_int.question_1b(n)[4][i]
			end
			mean = sum/n
			@fact mean --> roughly(0;atol=.1)
		end


		facts("Question 1c") do
			@fact length(HW_int.question_1c(n)[3]) --> n
			@fact typeof(HW_int.question_1c(n)[3]) --> Array{Float64,1}
			sum = 0
			for i in 1:n
				@fact HW_int.question_1c(n)[3][i] --> greater_than(1)
				@fact HW_int.question_1c(n)[3][i] --> less_than(4)

				# Calculate the mean of nodes, should be around 2.5 since nodes are normally dist. between 1 and 4
				sum = sum + HW_int.question_1c(n)[3][i]
			end
			mean = sum/n
			@fact mean --> roughly(2.5;atol=.5)
		end

		facts("Question 1d") do
			@fact length(HW_int.question_1d(n)[3]) --> n
			@fact typeof(HW_int.question_1d(n)[3]) --> Array{Float64,2}
			sum = 0
			for i in 1:n
				@fact HW_int.question_1d(n)[3][i] --> greater_than(1)
				@fact HW_int.question_1d(n)[3][i] --> less_than(4)

				# Calculate the mean of nodes, should be around 2.5 since nodes are normally dist. between 1 and 4
				sum = sum + HW_int.question_1d(n)[3][i]
			end
			mean = sum/n
			@fact mean --> roughly(2.5;atol=.5)
		end

		facts("Question 2a") do
			@fact length(HW_int.question_2a(10)[4]) --> 200 # 2 dims and 2 columns
			sum = 0
			for i in 1:100
				# Calculate the mean of nodes, should be around 0 since nodes are normally dist.
				sum = sum + HW_int.question_2a(10)[4][i,1] # dim 1
			end
			mean = sum/100
			@fact mean --> roughly(0;atol=.1)
			for i in 1:100
				# Calculate the mean of nodes, should be around 0 since nodes are normally dist.
				sum = sum + HW_int.question_2a(10)[4][i,2] # dim 2
			end
			mean = sum/100
			@fact mean --> roughly(0;atol=.1)
		end

		facts("Question 2b") do
			# in monte carlo, nodes are drawn from joint lognormal, so each dimension should have mean 1
			@fact length(HW_int.question_2b(10)[4]) --> 200
			sum = 0
			A = HW_int.question_2b(10)[4]
			for i in 1:100
				sum = sum + A[1,i] # dim 1
			end
			mean = sum/100
			@fact mean --> roughly(1;atol=.1)
			sum = 0
			for i in 1:100
				# Calculate the mean of nodes, should be around 0 since nodes are normally dist.
				sum = sum + A[2,i] # dim 2
			end
			mean = sum/100
			@fact mean --> roughly(1;atol=.1)
		end

	end

	facts("Testing the price fuction from Question 2") do
		#for theta_1 and theta_2 equal to one, the equilibrium price should be 1
		# as it's obvious from the demand=supply eqm condition
		# let's see whether this price function works in functions question_2a and 2b
		A = [1.0,1.0] #thetas
		@fact HW_int.question_2a(10)[5](A) --> 1.0
		@fact HW_int.question_2b(10)[5](A) --> 1.0

	end

end
